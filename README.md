Run preprocess.py > architecture.py > main.py.

Short description:
I use presidential vote data from the MIT Election Data and Science Lab, which provides county-level vote counts from 2000 to 2020 along with a range of county-level covariates. To mimic real-time election night forecasting, I consider the problem of predicting 2020 vote shares using 2012 and 2016 vote shares, along with the first half of the 2020 vote shares. The benchmark for evaluation is the remaining half of the 2020 vote shares. The order in which 2020 counties are used follows the actual sequence in which states released their results on election night. I use shares from the first 25 states. Counties may not be interchangeable, but we assume that they are exchangeable conditionally on the observed covariates and further assume that county-level covariates are time-invariant. 

I used a 4-layer neural network for the training model. The model maps a covariate vector to the vote share, a scalar. Denote $p$ for the total number of covariates. The network maps $\mathbb{R}^p \rightarrow \mathbb{R}^{6p} \rightarrow \mathbb{R}^{4p} \rightarrow \mathbb{R}^{2p} \rightarrow \mathbb{R} \rightarrow [0, 1]$. The last step uses the sigmoid function. The list of covariates used can be found below. I run each model 7,000 times for training. I used the 10-fold CV+ mode for conformal prediction. I found that the training loss almost always spikes in one or two folds. This seems to be due to existence of some outliers or sparsely distributed strata. I drop predictions from those folds. $\alpha=0.1$, so the intervals target 90\% coverage on average and guarantee at least 80\% coverage.
